---
layout: post
title: Android 资源文件创建与加载
key: 20171218
tags: Android 资源文件
---

### <i class="fa fa-rebel fa-1x" aria-hidden="true"></i> 概述
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Android 应用程序启动之后，资源文件就能够通过 Resource 类访问，说明随着 App 的启动，资源文件已经创建好了，并且保存在 Resource 类中，这个过程是系统做的；本篇内容就是来分析 Resource 是如何初始化及如何通过 Resource 获取资源文件。
### <i class="fa fa-rebel fa-1x" aria-hidden="true"></i> 资源文件Resource的创建
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
通过跟踪源码，发现资源文件 Resource 是在 ContextImpl 初始化方法里面创建的，而我们知道ContextImpl的初始化不是唯一的，在 App 启动的时候会初始化一个全局的ContextImpl，作为整个 App的全局上下文，而每个 Activity 创建的时候也会创建一个ContextImpl 与之对应，此时ContextImpl 为当前 Activity 的上下文，会随 Activity 的销毁而销毁；那么，问题来了，Resource应该是全局的资源文件，不应该是每个 Activity 的创建的时候都创建一遍，所以现在的解决方案是通过缓存的方式把资源缓存起来，每次先从缓存中判断是否已经创建过。创建的流程图如下：
![](/assets/assetcreate/AssetCreat.png)
接下来进入源码分析阶段
##### <i class="fa fa-star" aria-hidden="true"></i> ContextImpl 的初始化
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
在前面Activity 启动分析中知道 app 的启动入口为 ActivityThread.main()里面会调用 AMS 的 attachApp 方法，attachApp 又会调用 app 端的handleBindApplication()，这里创建了 App 的全局上下文ContextImpl,也是第一次对 ContextImpl 初始化，构造方法中调用了LoadedApk 的getResources。
##### <i class="fa fa-star" aria-hidden="true"></i> LoadedApk.getResources()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
把处理过程交给 ActivityThread，这些参数都是相关资源文件的文件路径。
```java
public Resources getResources(ActivityThread mainThread) {
    if (mResources == null) {
        mResources = mainThread.getTopLevelResources(mResDir, mSplitResDirs, mOverlayDirs,
                mApplicationInfo.sharedLibraryFiles, Display.DEFAULT_DISPLAY, this);
    }
    return mResources;
}
```
##### <i class="fa fa-star" aria-hidden="true"></i> ActivityThread.getTopLevelResources()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
再次把处理过程交给下一级 ResourcesManager
```java
Resources getTopLevelResources(String resDir, String[] splitResDirs, String[] overlayDirs,
        String[] libDirs, int displayId, LoadedApk pkgInfo) {
    return mResourcesManager.getResources(null, resDir, splitResDirs, overlayDirs, libDirs,
            displayId, null, pkgInfo.getCompatibilityInfo(), pkgInfo.getClassLoader());
}
```
##### <i class="fa fa-star" aria-hidden="true"></i> ResourcesManager.getResources()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
创建 resourceKey 用于作为资源文件的缓存 key。
```java
public @NonNull Resources getResources(@Nullable IBinder activityToken,
        @Nullable String resDir,
        @Nullable String[] splitResDirs,
        @Nullable String[] overlayDirs,
        @Nullable String[] libDirs,
        int displayId,
        @Nullable Configuration overrideConfig,
        @NonNull CompatibilityInfo compatInfo,
        @Nullable ClassLoader classLoader) {
    try {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, "ResourcesManager#getResources");
        final ResourcesKey key = new ResourcesKey(
                resDir,
                splitResDirs,
                overlayDirs,
                libDirs,
                displayId,
                overrideConfig != null ? new Configuration(overrideConfig) : null, // Copy
                compatInfo);
        classLoader = classLoader != null ? classLoader : ClassLoader.getSystemClassLoader();
        return getOrCreateResources(activityToken, key, classLoader);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    }
}
```
### <i class="fa fa-rebel fa-1x" aria-hidden="true"></i> 资源文件的加载
##### <i class="fa fa-star" aria-hidden="true"></i> 资源文件加载流程图
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
![](/assets/assetcreate/getAsset.png)


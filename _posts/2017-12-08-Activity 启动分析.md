---
layout: post
title: Activity 启动分析
key: 20171208
tags: Acvitity Android
---

### <i class="fa fa-rebel fa-1x" aria-hidden="true"></i>  概述
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Acvitity 作为 Android 四大组件中使用频率最高的组件，作为 Android 开发者，对于 Activity 的启动一点都不陌生，包括他的启动方式，启动模式，因为这都可能在开发过程中用到，但是启动的内部流程我们却往往并不关心，系统已封装好，作为一名合格的程序猿，系统服务也是该掌握的。
##### <i class="fa fa-star" aria-hidden="true"></i> Activity 启动方式
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
从大方向来分，Activity 的启动分为显示启动和隐式启动两种启动方式<br>
1.显示启动：<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据类名启动
```java
Intent it = new Intent(A.this,B.class);
startActivity(it);
```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据包名启动
```java
Intent it = new Intent(A.this,B.class);
it.setComponent(new ComponentName("package","class"));
startActivity(it);
```
2.显示启动：<br>
```java
Intent it = new Intent("action");
startActivity(it);
```
无论哪种启动方式，最终都会进入startActivity()方法。
##### <i class="fa fa-star" aria-hidden="true"></i> 启动流程图解
[查看大图](www)

![](/assets/activitystart/startActivity.png)

其中：
 + AMProxy:ActivityManagerProxy
 + AMNative:ActivityManagerNative
 + AMS:ActivityManagerService
 + AS:ActivityStarter
 + ASS:ActivityStackSupervisor
 + AStack:ActivityStack

### <i class="fa fa-rebel fa-1x" aria-hidden="true"></i> 代码跟踪
1、Activity 中的 startActivity
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
该方法最终会进入startActivityForResult，Activity 中的 parent 始终为空
```java
    public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,
            @Nullable Bundle options) {
        //进入该分支
        if (mParent == null) {
            Instrumentation.ActivityResult ar =
                mInstrumentation.execStartActivity(
                    this, mMainThread.getApplicationThread(), mToken, this,
                    intent, requestCode, options);
            if (ar != null) {
                mMainThread.sendActivityResult(
                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),
                    ar.getResultData());
            }
            cancelInputsAndStartExitTransition(options);
        }
    }
```
2、Instrumentation 中的 execStartActivity
```java
    public ActivityResult execStartActivity(
            Context who, IBinder contextThread, IBinder token, Activity target,
            Intent intent, int requestCode, Bundle options) {
        IApplicationThread whoThread = (IApplicationThread) contextThread;
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(who);
            int result = ActivityManagerNative.getDefault()
                .startActivity(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target != null ? target.mEmbeddedID : null,
                        requestCode, 0, null, options);
            checkStartActivityResult(result, intent);
        } catch (RemoteException e) {
            throw new RuntimeException("Failure from system", e);
        }
        return null;
    }
```
`ActivityManagerNative.getDefault()` 实则通过 ServiceManager 获取 Activity Binder 服务，实现当前进程能够与 service 进程通信的能力。

3、ActivityManagerProxy.startActivity()方法中的transact() 与 ActivityManagerNative.onTransact()就是客户端与服务端通信的两个函数，
```java
public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,
                         String resolvedType, IBinder resultTo, String resultWho, int requestCode,
                         int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeStrongBinder(caller != null ? caller.asBinder() : null);
    data.writeString(callingPackage);
    intent.writeToParcel(data, 0);
    data.writeString(resolvedType);
    data.writeStrongBinder(resultTo);
    data.writeString(resultWho);
    data.writeInt(requestCode);
    data.writeInt(startFlags);
    if (profilerInfo != null) {
        data.writeInt(1);
        profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
    } else {
        data.writeInt(0);
    }
    if (options != null) {
        data.writeInt(1);
        options.writeToParcel(data, 0);
    } else {
        data.writeInt(0);
    }
    mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);
    reply.readException();
    int result = reply.readInt();
    reply.recycle();
    data.recycle();
    return result;
}
```
关键参数说明：
+ IApplicationThread caller：调用者 Binder,service 进程可以通过它实现数据交互
+ IBinder resultTo：调用 Activity 的一个唯一标识 token 值

ActivityManagerNative.onTransact()调用进入到 AMS的startActivity()。

4、AMS.startActivity()->AMS.startActivityAsUser()->AS.startActivityMayWait()
```java
int startActivityMayWait(IApplicationThread caller, int callingUid,
                               String callingPackage, Intent intent, String resolvedType,
                               IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
                               IBinder resultTo, String resultWho, int requestCode, int startFlags,
                               ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,
                               Bundle bOptions, boolean ignoreTargetSecurity, int userId,
                               IActivityContainer iContainer, TaskRecord inTask) {


    //通过 Intent 解析相关信息
    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);
    // 解析 ActivityInfo.
    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);

    ActivityOptions options = ActivityOptions.fromBundle(bOptions);
    ActivityStackSupervisor.ActivityContainer container =
            (ActivityStackSupervisor.ActivityContainer)iContainer;
    synchronized (mService) {
        final ActivityRecord[] outRecord = new ActivityRecord[1];
        int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,
                aInfo, rInfo, voiceSession, voiceInteractor,
                resultTo, resultWho, requestCode, callingPid,
                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,
                options, ignoreTargetSecurity, componentSpecified, outRecord, container,
                inTask);


        return res;
    }
}
```
解析需要跳转 Activity 的信息，然后启动。

5、AS.startActivityLocked()
```java
final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,
                              String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,
                              IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
                              IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,
                              String callingPackage, int realCallingPid, int realCallingUid, int startFlags,
                              ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,
                              ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,
                              TaskRecord inTask) {

    ActivityRecord sourceRecord = null;
    ActivityRecord resultRecord = null;
    final int launchFlags = intent.getFlags();

    final ActivityStack resultStack = resultRecord == null ? null : resultRecord.task.stack;
    //检查 Activity 的启动权限
    boolean abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho,
            requestCode, callingPid, callingUid, callingPackage, ignoreTargetSecurity, callerApp,
            resultRecord, resultStack, options);
    abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid,
            callingPid, resolvedType, aInfo.applicationInfo);
    // 这里没有给ProcessRecord app 赋值;
    ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage,
            intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,
            requestCode, componentSpecified, voiceSession != null, mSupervisor, container,
            options, sourceRecord);
    if (outActivity != null) {
        outActivity[0] = r;
    }
    try {
        mService.mWindowManager.deferSurfaceLayout();
        err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags,
                true, options, inTask);
    } finally {
        mService.mWindowManager.continueSurfaceLayout();
    }
    postStartActivityUncheckedProcessing(r, err, stack.mStackId, mSourceRecord, mTargetStack);
    return err;
}
```
校验 Activity 的权限，创建待启动的 ActivityRecodrd 对象，并初始化部分变量，ActivityRecodrd中的ProcessRecord成员变量尚未赋值，当前值为 null。

5、AS.startActivityUnchecked()
```java
private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,
                                   IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
                                   int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) {
    //初始化启动状态
    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,
            voiceInteractor);
    final ActivityStack topStack = mSupervisor.mFocusedStack;
    final ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(mNotTop);

    mTargetStack.startActivityLocked(mStartActivity, newTask, mKeepCurTransition, mOptions);
    //mDoResume 为 true
    if (mDoResume) {
        final ActivityRecord topTaskActivity = mStartActivity.task.topRunningActivityLocked();
        if (!mTargetStack.isFocusable()
                || (topTaskActivity != null && topTaskActivity.mTaskOverlay
                && mStartActivity != topTaskActivity)) {
            mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);
            mWindowManager.executeAppTransition();
        } else {
            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,
                    mOptions);
        }
    }
    mSupervisor.updateUserStackLocked(mStartActivity.userId, mTargetStack);

    mSupervisor.handleNonResizableTaskIfNeeded(
            mStartActivity.task, preferredLaunchStackId, mTargetStack.mStackId);

    return START_SUCCESS;
}
```
mDoResume 参数在传入的时候直接赋值为 ture。

6、ASS.resumeFocusedStackTopActivityLocked()->AStack.resumeTopActivityUncheckedLocked()->AStack.resumeTopActivityInnerLocked()
```java
private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {
    //系统未启动，直接返回
    if (!mService.mBooting && !mService.mBooted) {
        // Not ready yet!
        return false;
    }
    //获取需要启动的ActivityRecord
    final ActivityRecord next = topRunningActivityLocked();

    final TaskRecord prevTask = prev != null ? prev.task : null;
    //启动 launcher，首次启动
    if (next == null) {
        return isOnHomeDisplay() &&
                mStackSupervisor.resumeHomeStackTask(returnTaskType, prev, reason);
    }
    ActivityStack lastStack = mStackSupervisor.getLastStack();
    //next 为需要启动的 ActivityRecord next.app 为空
    if (next.app != null && next.app.thread != null) {
    } else {
        // Whoops, need to restart this activity!
        mStackSupervisor.startSpecificActivityLocked(next, true, true);
    }

    if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
    return true;
}
```
代码很长，只提取有用的部分，判断系统服务是否已经启动，下一个需要启动的 Activity 不存在，直接启动 Launcher,在前面初始化 ActivityRecord的时候，没有给 app赋值，所以这里直接进入startSpecificActivityLocked()。

7、ASS.startSpecificActivityLocked()
```java
void startSpecificActivityLocked(ActivityRecord r,
                                 boolean andResume, boolean checkConfig) {
    // 获取待启动 Activity 的进程
    ProcessRecord app = mService.getProcessRecordLocked(r.processName,
            r.info.applicationInfo.uid, true);

    r.task.stack.setLaunchTime(r);
    //待启动 Activity 的进程存在
    if (app != null && app.thread != null) {
        try {
            if ((r.info.flags&ActivityInfo.FLAG_MULTIPROCESS) == 0
                    || !"android".equals(r.info.packageName)) {

                app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,
                        mService.mProcessStats);
            }
            realStartActivityLocked(r, app, andResume, checkConfig);
            return;
        } catch (RemoteException e) {
            Slog.w(TAG, "Exception when starting activity "
                    + r.intent.getComponent().flattenToShortString(), e);
        }
    }
    // 进程不存在，需要创建
    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,
            "activity", r.intent.getComponent(), false, false, true);
}

```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
### <i class="fa fa-rebel fa-1x" aria-hidden="true"></i> 总结


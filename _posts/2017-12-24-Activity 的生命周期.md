---
layout: post
title:  Activity 的生命周期
key: 20171224
tags: Android Activity
---

### <i class="fa fa-rebel fa-1x" aria-hidden="true"></i>  生命周期
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Activity 生命周期的重要性不言而喻，我们熟知的有以下几种 onCreate、onStart、onResume、onPause、onStop、onDestory，当然还有一些不常使用的，如：onPostCreate等。他们的调用顺序依次是 onCreate -> onStart -> onResume -> onPause -> onStop -> onDestory。本篇文章的内容是理解其每个生命周期的调用者，及调用时机。
##### <i class="fa fa-star" aria-hidden="true"></i> 官方图解
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面给出一张官方的生命周期示意图

![](/assets/activitylifecycle/activity_lifecycle.png)

### <i class="fa fa-rebel fa-1x" aria-hidden="true"></i> 生命周期分解
##### <i class="fa fa-star" aria-hidden="true"></i> onCreate
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
以 Activity 的创建开始分析，在前面文章中 [Activity 的启动分析]()中我们知道，system_server 通过 binder 机制调用 app 的scheduleLaunchActivity 才算 Activity 的正式启动，那么生命周期也必定从这里开始，下面就来分析分析。因为任何 binder server 都是一个子线程，所以scheduleLaunchActivity 必定是在一个子线程中，而 Activity 的生命周期是在主线程中执行，需要通过 Hander 机制转到主线程中，调用 ActivityThread 的 handleLaunchActivity方法，最终调用 performLaunchActivity 方法。
```java
private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
	...
    Activity activity = null;
    try {
        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
        //反射创建 Activity
        activity = mInstrumentation.newActivity(
                cl, component.getClassName(), r.intent);
        StrictMode.incrementExpectedActivityCount(activity.getClass());
        r.intent.setExtrasClassLoader(cl);
        r.intent.prepareToEnterProcess();
        if (r.state != null) {
            r.state.setClassLoader(cl);
        }
    } catch (Exception e) {
    }
    try {
        Application app = r.packageInfo.makeApplication(false, mInstrumentation);
        if (activity != null) {
           ...
           //调用 activity 的 attach 方法，此方法比 onCreate 更早调用
            activity.attach(appContext, this, getInstrumentation(), r.token,
                    r.ident, app, r.intent, r.activityInfo, title, r.parent,
                    r.embeddedID, r.lastNonConfigurationInstances, config,
                    r.referrer, r.voiceInteractor, window);

            activity.mCalled = false;
            if (r.isPersistable()) {
                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
            } else {
                mInstrumentation.callActivityOnCreate(activity, r.state);
            }
            r.activity = activity;
            r.stopped = true;
            if (!r.activity.mFinished) {
                activity.performStart();
                r.stopped = false;
            }
            if (!r.activity.mFinished) {
                if (r.isPersistable()) {
                    if (r.state != null || r.persistentState != null) {
                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,
                                r.persistentState);
                    }
                } else if (r.state != null) {
                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);
                }
            }
            if (!r.activity.mFinished) {
                activity.mCalled = false;
                if (r.isPersistable()) {
                    mInstrumentation.callActivityOnPostCreate(activity, r.state,
                            r.persistentState);
                } else {
                    mInstrumentation.callActivityOnPostCreate(activity, r.state);
                }
            }
        }
        r.paused = true;
        mActivities.put(r.token, r);
    } catch (SuperNotCalledException e) {
        throw e;
    }
    return activity;
}
```
由以上代码可知，在调用完 activity 的 attach 之后，就调用`mInstrumentation.callActivityOnCreate(activity, r.state);`
```java
public void callActivityOnCreate(Activity activity, Bundle icicle) {
    prePerformCreate(activity);
    //调用 Activity 的 create 方法
    activity.performCreate(icicle);
    postPerformCreate(activity);
}

```
onCreate被调用。
##### <i class="fa fa-star" aria-hidden="true"></i> onStart
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
在跟踪 onCreate 方法的时候我们发现
```java
if (!r.activity.mFinished) {
    activity.performStart();
    r.stopped = false;
}
```
紧跟着`mInstrumentation.callActivityOnCreate(activity, r.state);`
##### <i class="fa fa-star" aria-hidden="true"></i> onResume
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
再回到 handleLaunchActivity 方法
```java
private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
    //...

    Activity a = performLaunchActivity(r, customIntent);

    if (a != null) {
        r.createdConfig = new Configuration(mConfiguration);
        reportSizeConfigurations(r);
        Bundle oldState = r.state;
        handleResumeActivity(r.token, false, r.isForward,
                !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);
	//...
    } else {
        // If there was an error, for any reason, tell the activity manager to stop us.
        try {
            ActivityManagerNative.getDefault()
                .finishActivity(r.token, Activity.RESULT_CANCELED, null,
                        Activity.DONT_FINISH_TASK_WITH_ACTIVITY);
        } catch (RemoteException ex) {
            throw ex.rethrowFromSystemServer();
        }
    }
}
```
从代码可知，在调用performLaunchActivity之后，调用了 handleResumeActivity，handleResumeActivity内部调用了 onResume 方法。<br>
以上就是 Activity 生命周期的前半部分，而且是 Activity 从无到有的情况下的前半部分，如果 Activity 被其他 Activity 覆盖之后再次被显示，其生命周期是怎么触发的？分析这种情况之前，先看看 Activity 生命周期的后半部分。
##### <i class="fa fa-star" aria-hidden="true"></i> onPause
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
以 Activity 销毁为例来分析，
##### <i class="fa fa-star" aria-hidden="true"></i> onStop
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
##### <i class="fa fa-star" aria-hidden="true"></i> onDestory
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
##### <i class="fa fa-star" aria-hidden="true"></i> 特殊的 onNewIntent
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
### <i class="fa fa-rebel fa-1x" aria-hidden="true"></i> 总结


---
layout: post
title:  Tinker 分析
key: 20171222
tags: Android 源码分析
---

### <i class="fa fa-rebel fa-1x" aria-hidden="true"></i>  概述
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Tinker 源码地址 [https://github.com/Tencent/tinker](https://github.com/Tencent/tinker)，作为热修复框架，支持修复代码、So库以及资源，让应用能够在不需要重新安装的情况下实现更新。
### <i class="fa fa-rebel fa-1x" aria-hidden="true"></i> 基本使用
##### <i class="fa fa-star" aria-hidden="true"></i> 生成插件
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
##### <i class="fa fa-star" aria-hidden="true"></i> 集成Tinker
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
### <i class="fa fa-rebel fa-1x" aria-hidden="true"></i> 源码分析
##### <i class="fa fa-star" aria-hidden="true"></i> 合并插件
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
插件是被编译成 apk，同时对插件 apk 进行了签名校验，解析合并插件的时候会先对插件文件进行签名校验，如果与当前运行程序前面不一致，则不合并，插件内容最多的情况包含三部分 dex 文件、res、so，也可以只有其中一种。
合并插件的流程图如下：

![](/assets/tinker/TinkerPatch.png)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
后台下发插件之后，需调用 TinkerInstaller.onPatchReceived()交由插件库去打补丁操作，这个过程的整体流程图如上，具体代码分为以下几点。

+ patchCheck，相关校验

```java
protected int patchCheck(String path, String patchMd5) {
    Tinker manager = Tinker.with(context);
    //Tinker是否开启
    if (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) {
        return ShareConstants.ERROR_PATCH_DISABLE;
    }
    File file = new File(path);
    //是否有效的补丁文件
    if (!SharePatchFileUtil.isLegalFile(file)) {
        return ShareConstants.ERROR_PATCH_NOTEXIST;
    }

    //当前进程是否在补丁进程，如果是，返回 error
    if (manager.isPatchProcess()) {
        return ShareConstants.ERROR_PATCH_INSERVICE;
    }

    //补丁进程 是否已经启动
    if (TinkerServiceInternals.isTinkerPatchServiceRunning(context)) {
        return ShareConstants.ERROR_PATCH_RUNNING;
    }
    //是否虚拟机 jit 编译模式
    if (ShareTinkerInternals.isVmJit()) {
        return ShareConstants.ERROR_PATCH_JIT;
    }

    Tinker tinker = Tinker.with(context);

    if (tinker.isTinkerLoaded()) {
        TinkerLoadResult tinkerLoadResult = tinker.getTinkerLoadResultIfPresent();
        if (tinkerLoadResult != null && !tinkerLoadResult.useInterpretMode) {
            String currentVersion = tinkerLoadResult.currentVersion;
            if (patchMd5.equals(currentVersion)) {
                return ShareConstants.ERROR_PATCH_ALREADY_APPLY;
            }
        }
    }

    if (!UpgradePatchRetry.getInstance(context).onPatchListenerCheck(patchMd5)) {
        return ShareConstants.ERROR_PATCH_RETRY_COUNT_LIMIT;
    }

    return ShareConstants.ERROR_PATCH_OK;
}
```

+ runPatchService，启动补丁服务，此服务另其一个进程，与 App 进程不是同一个

```java
public static void runPatchService(Context context, String path) {
    try {
        Intent intent = new Intent(context, TinkerPatchService.class);
        //补丁文件路径
        intent.putExtra(PATCH_PATH_EXTRA, path);
        //补丁合成成功之后，待启动服务的名称，用于做合成之后的相关操作，比如，结束 app 进程
        intent.putExtra(RESULT_CLASS_EXTRA, resultServiceClass.getName());
        context.startService(intent);
    } catch (Throwable throwable) {
        TinkerLog.e(TAG, "start patch service fail, exception:" + throwable);
    }
}
```

+ onHandleIntent，intentservice的异步函数，此函数运行完之后，会自动结束服务，补丁合成的入口

```java
@Override
protected void onHandleIntent(Intent intent) {
    final Context context = getApplicationContext();
    Tinker tinker = Tinker.with(context);
    //打补丁操作开始回掉
    tinker.getPatchReporter().onPatchServiceStart(intent);

    if (intent == null) {
        TinkerLog.e(TAG, "TinkerPatchService received a null intent, ignoring.");
        return;
    }
    String path = getPatchPathExtra(intent);
    if (path == null) {
        TinkerLog.e(TAG, "TinkerPatchService can't get the path extra, ignoring.");
        return;
    }
    File patchFile = new File(path);
    //补丁开始的时间
    long begin = SystemClock.elapsedRealtime();
    boolean result;
    long cost;
    Throwable e = null;
    //增加 service 的优先级，让服务不容易杀死
    increasingPriority();
    PatchResult patchResult = new PatchResult();
    try {
        if (upgradePatchProcessor == null) {
            throw new TinkerRuntimeException("upgradePatchProcessor is null.");
        }
        //真正执行打补丁操作
        result = upgradePatchProcessor.tryPatch(context, path, patchResult);
    } catch (Throwable throwable) {
        e = throwable;
        result = false;
        //回掉补丁失败之后的结果
        tinker.getPatchReporter().onPatchException(patchFile, e);
    }
    //获取耗时
    cost = SystemClock.elapsedRealtime() - begin;
    //回掉补丁成功之后的结果
    tinker.getPatchReporter().
        onPatchResult(patchFile, result, cost);

    patchResult.isSuccess = result;
    patchResult.rawPatchFilePath = path;
    patchResult.costTime = cost;
    patchResult.e = e;
    //启动补丁合成之后处理相关操作的 service
    AbstractResultService.runResultService(context, patchResult, getPatchResultExtra(intent));

}
```

+ tryPatch

```java

```
###### 合并 dex

###### 合并 res
###### 合并 so
##### <i class="fa fa-star" aria-hidden="true"></i> 加载插件
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
###### 加载 dex
###### 加载 res
###### 加载 so
### <i class="fa fa-rebel fa-1x" aria-hidden="true"></i> 总结

